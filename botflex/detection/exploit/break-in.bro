##! This script analyzes if remote host(s) are trying to break into
##! the monitored network. 

@load base/protocols/ssh
@load botflex/config
@load botflex/utils/types

module Breakin;

export {
	redef enum Log::ID += { LOG };

	type Info: record {
		ts:                time             &log;
		victim_ip:         addr             &log;
		ssh_attackers:     string           &log;
		msg:               string           &log;
	};
	
	redef record connection += {
	conn: Info &optional;
	};
	
	## The contributory factors to the event breakin
	type breakin_tributary: enum { Ssh_failed_login };

	## The evaluation mode (one of the modes defined in enum evaluation_mode in utils/types)
	const breakin_evaluation_mode = OR &redef;

	## Event that can be handled to access the breakin
	## record as it is sent on to the logging framework.
	global log_breakin: event(rec: Info);

	## The event that spam.bro reported spam
	global breakin: event( victim_ip: addr, ssh_attackers: set[addr], msg: string );

	## Thresholds for different contributors to the major event exploit
	const ssh_login_threshold = 10 &redef;

	## Expire interval for the global table concerned with maintaining break in info
	const wnd_breakin = 10mins;
       }

global breakin_info:Breakin::Info;

event bro_init() &priority=5
	{	
	Log::create_stream(Breakin::LOG, [$columns=Info, $ev=log_breakin]);
	}

event Input::update_finished(name: string, source: string) 
	{
	if ( name == "config_stream" )
		{
		if ( "th_ssh_login" in Config::table_config )
			ssh_login_threshold = to_count(Config::table_config["th_ssh_login"]$value);
		else
			print "Can't find Breakin::th_ssh_login";

		if ( "wnd_breakin" in Config::table_config )
				{
				local str_interval = Config::table_config["wnd_breakin"]$value;
				wnd_breakin = string_to_interval(str_interval);
				}
		else
			print "Can't find Breakin::wnd_breakin";
			
		if ( "evaluation_breakin_mode" in Config::table_config )
			{
			local str_mode = Config::table_config["evaluation_breakin_mode"]$value;
			breakin_evaluation_mode = string_to_evaluationmode(str_mode);
			}
		else
			print "Can't find Breakin::evaluation_breakin_mode";
		}
	}

## Type of the value of the global table table_breakin
## Additional contributary factors that increase the confidence
## about major event exploit should be added here
type BreakinRecord: record {
    tb_tributary: table[ breakin_tributary ] of bool;
    ssh_logins: count &default=0;
    ssh_attackers: set[addr];  		
};

## The following set of functions calculate and, or and majority on a table of
## booleans
function get_and( tb : table[breakin_tributary] of bool ): bool
	{
	for ( rec in tb )
		{
		if ( !tb[rec] )
			return F;
		}
	return T;
	}

function get_or( tb : table[breakin_tributary] of bool ): bool
	{
	for ( rec in tb )
		{
		if ( tb[rec] )
			return T;
		}
	return F;	
	}

function get_majority( tb : table[breakin_tributary] of bool ): bool
	{
	local t = 0;
	local f = 0;
	for ( rec in tb )
		{
		if ( tb[rec] )
			++t;
		else
			++f;
		}

	if ( f > t )
		return F;
	else
		return T;
	}


function evaluate_breakin( dst_ip: addr, t: table[addr] of BreakinRecord  ): bool
	{
	local do_report: bool;
	if ( breakin_evaluation_mode == OR )
		do_report = get_or(t[dst_ip]$tb_tributary);
	else if ( breakin_evaluation_mode == AND )
		do_report = get_and(t[dst_ip]$tb_tributary);
	else if ( breakin_evaluation_mode == MAJORITY )
		do_report = get_majority(t[dst_ip]$tb_tributary);
		
	if( do_report )
		{
		local msg = "";
		if ( t[dst_ip]$tb_tributary[Ssh_failed_login] )
			msg = "Failed SSH login attempts";

		event Breakin::breakin( dst_ip, t[dst_ip]$ssh_attackers, msg );

		## Log breakin-related entries
		breakin_info$ts = network_time();
		breakin_info$victim_ip = dst_ip;
		breakin_info$ssh_attackers = setaddr_to_string(t[dst_ip]$ssh_attackers, ",");
		breakin_info$msg = msg;

		Log::write(Breakin::LOG,breakin_info);

		return T;
		}	
	return F;	
	}

## Called when an entry in the global table table_breakin exceeds certain age, as specified
## in the table attribute create_expire.
function breakin_record_expired(t: table[addr] of BreakinRecord, idx: any): interval
	{
	evaluate_breakin(idx, t);
	return wnd_breakin;
	}

# The global state table that maintains various information pertaining to the
## major exploit, and is analyzed when a decision has to be made whether
## or not to declare the major event exploit.
global table_breakin: table[addr] of BreakinRecord &create_expire=0secs &expire_func=breakin_record_expired;	

function get_breakin_record(): BreakinRecord
	{
	local rec: BreakinRecord;
	local s: set[addr];
	rec$ssh_attackers = s;
	return rec;
	}

## Keep track of the total number of inbound failed ssh logins within a 
## time window, regardless of the source ip. For all we know, the attacker
## might be using spoofed source ip's to force his way into our host.
event SSH::heuristic_failed_login(c: connection)
	{
	local outbound = Site::is_local_addr(c$id$orig_h);

	if ( !outbound )
		{
		local id = c$id;
		local victim = id$resp_h;

		# if this is the first time src_ip appears
		if ( victim !in table_breakin )
			table_breakin[victim] = get_breakin_record();

		++ table_breakin[victim]$ssh_logins;
		add table_breakin[victim]$ssh_attackers[id$orig_h];
	
		if ( table_breakin[victim]$ssh_logins > ssh_login_threshold )
			{
			table_breakin[victim]$tb_tributary[ Ssh_failed_login ] = T;
			local done = evaluate_breakin( victim, table_breakin );
			if ( done )
				{
				delete table_breakin[victim]$tb_tributary[ Ssh_failed_login ];
				table_breakin[victim]$ssh_logins = 0;
				for ( rec in table_breakin[victim]$ssh_attackers )
					delete table_breakin[victim]$ssh_attackers[rec];
				}
			}
		}
	}


